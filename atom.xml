<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的博客</title>
  
  <subtitle>一天进步一点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://junzhengsong.github.io/"/>
  <updated>2023-01-24T04:52:42.241Z</updated>
  <id>https://junzhengsong.github.io/</id>
  
  <author>
    <name>Song Junzheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/24/MySQL%E7%AC%94%E8%AE%B0/"/>
    <id>https://junzhengsong.github.io/2023/01/24/MySQL笔记/</id>
    <published>2023-01-24T04:52:42.241Z</published>
    <updated>2023-01-24T04:52:42.241Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/24/Redis%E7%AC%94%E8%AE%B0/"/>
    <id>https://junzhengsong.github.io/2023/01/24/Redis笔记/</id>
    <published>2023-01-24T04:26:03.439Z</published>
    <updated>2023-01-24T04:52:31.765Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Redis学习笔记（一）"><a href="#Redis学习笔记（一）" class="headerlink" title="Redis学习笔记（一）"></a>Redis学习笔记（一）</h2><h3 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h3><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p><p>Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p><p>除此之外，Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制</strong>等等。 </p><blockquote><ul><li>消息队列：消息队列是一种异步的服务间通信方式，适用于无服务器和微服务架构。消息在被处理和删除之前一直存储在队列上。每条消息仅可被一位用户处理一次。消息队列可被用于分离重量级处理、缓冲或批处理工作以及缓解高峰期工作负载。解耦、削峰、限流</li><li>分布式锁：控制分布式系统不同进程共同访问共享资源的一种锁的实现。</li><li>原子性：一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>事物：访问并可能操作各种数据项的一个数据库操作序列</li><li></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;Redis学习笔记（一）&quot;&gt;&lt;a href=&quot;#Redis学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;Redis学习笔记（一）&quot;&gt;&lt;/a&gt;Redis学习笔记（一）&lt;/h2&gt;&lt;h3 id=&quot;什么是Redis？&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/22/%E5%B0%8F%E6%9E%97%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/22/小林网络笔记（四）/</id>
    <published>2023-01-22T11:26:33.624Z</published>
    <updated>2023-01-22T11:26:33.624Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/22/%E5%B0%8F%E6%9E%97%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/22/小林网络笔记（总结）/</id>
    <published>2023-01-22T11:26:33.624Z</published>
    <updated>2023-01-22T11:26:52.901Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/22/%E5%B0%8F%E6%9E%97%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/22/小林网络笔记（三）/</id>
    <published>2023-01-22T11:25:00.469Z</published>
    <updated>2023-01-23T13:23:44.005Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="小林图解网络（TCP篇）"><a href="#小林图解网络（TCP篇）" class="headerlink" title="小林图解网络（TCP篇）"></a>小林图解网络（TCP篇）</h2><h1 id="4-1-TCP-三次握手与四次挥手面试题"><a href="#4-1-TCP-三次握手与四次挥手面试题" class="headerlink" title="4.1 TCP 三次握手与四次挥手面试题"></a>4.1 TCP 三次握手与四次挥手面试题</h1><h3 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h3><p><img src="https://img-blog.csdnimg.cn/1310bf5ed78e4c8186481c47719e0793.png" alt="img"></p><hr><h2 id="TCP-基本认识"><a href="#TCP-基本认识" class="headerlink" title="TCP 基本认识"></a>TCP 基本认识</h2><h3 id="TCP-头格式有哪些？"><a href="#TCP-头格式有哪些？" class="headerlink" title="TCP 头格式有哪些？"></a>TCP 头格式有哪些？</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn?x-oss-process=image/format,png" alt="TCP 头格式"></p><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><blockquote><p>SYN为1的TCP报文段不能含有数据</p></blockquote><h3 id="为什么需要-TCP-协议？-TCP-工作在哪一层？"><a href="#为什么需要-TCP-协议？-TCP-工作在哪一层？" class="headerlink" title="为什么需要 TCP 协议？ TCP 工作在哪一层？"></a>为什么需要 TCP 协议？ TCP 工作在哪一层？</h3><p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzcuanBn?x-oss-process=image/format,png" alt="OSI 参考模型与 TCP/IP 的关系"></p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h3 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzguanBn?x-oss-process=image/format,png" alt="img"></p><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><blockquote><p><strong>我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议</strong>。</p></blockquote><h3 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h3><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzkuanBn?x-oss-process=image/format,png" alt="img"></p><p>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><h3 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a>如何唯一确定一个 TCP 连接呢？</h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEwLmpwZw?x-oss-process=image/format,png" alt="TCP 四元组"></p><p>源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p><p>源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p><h3 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p><p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（64 位），UDP 的头部格式如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEyLmpwZw?x-oss-process=image/format,png" alt="UDP 头部格式"></p><ul><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><p><strong>TCP 和 UDP 区别：</strong></p><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><strong>TCP 和 UDP 应用场景：</strong></p><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP / HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;小林图解网络（TCP篇）&quot;&gt;&lt;a href=&quot;#小林图解网络（TCP篇）&quot; class=&quot;headerlink&quot; title=&quot;小林图解网络（TCP篇）&quot;&gt;&lt;/a&gt;小林图解网络（TCP篇）&lt;/h2&gt;&lt;h1 id=&quot;4-1-TCP-三次握手与四次挥手面试题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/22/%E5%B0%8F%E6%9E%97%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/22/小林网络笔记（二）/</id>
    <published>2023-01-22T11:25:00.469Z</published>
    <updated>2023-01-23T12:51:57.232Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="小林图解网络（HTTP篇）"><a href="#小林图解网络（HTTP篇）" class="headerlink" title="小林图解网络（HTTP篇）"></a>小林图解网络（HTTP篇）</h2><h2 id="HTTP-基本概念"><a href="#HTTP-基本概念" class="headerlink" title="HTTP 基本概念"></a>HTTP 基本概念</h2><h3 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h3><p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li><p>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p></li><li><p>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</p></li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h3 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h3><p><em>Host</em> 字段</p><p>客户端发送请求时，用来指定服务器的域名。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/7-HOST%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.A.com</span><br></pre></td></tr></table></figure><p>有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</p><p><em>Content-Length 字段</em></p><p>服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/8-content-length%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 1000</span><br></pre></td></tr></table></figure><p>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p><p>大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，<strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong>。具体什么是 TCP 粘包，可以看这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/tcp_stream.html">如何理解是 TCP 面向字节流协议？(opens new window)</a></p><p><em>Connection 字段</em></p><p><code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/9-connection%E5%AD%97%E6%AE%B5.png" alt="img"></p><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d2b20d1cc03936332adb2a68512eb167.png" alt="HTTP 长连接"></p><p>HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p>开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</p><p>PS：大家不要把 HTTP Keep-Alive 和 TCP Keepalive 搞混了，这两个虽然长的像，但是不是一个东西，具体可以看我这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html">TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？(opens new window)</a></p><p><em>Content-Type 字段</em></p><p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/10-content-type%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; Charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p><p><em>Content-Encoding 字段</em></p><p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/11-content-encoding%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p><p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;小林图解网络（HTTP篇）&quot;&gt;&lt;a href=&quot;#小林图解网络（HTTP篇）&quot; class=&quot;headerlink&quot; title=&quot;小林图解网络（HTTP篇）&quot;&gt;&lt;/a&gt;小林图解网络（HTTP篇）&lt;/h2&gt;&lt;h2 id=&quot;HTTP-基本概念&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/22/%E5%B0%8F%E6%9E%97%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/22/小林网络笔记（一）/</id>
    <published>2023-01-22T10:37:07.181Z</published>
    <updated>2023-01-22T11:24:46.490Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-小林图解网络笔记（基础篇）"><a href="#title-小林图解网络笔记（基础篇）" class="headerlink" title="title:小林图解网络笔记（基础篇）"></a>title:小林图解网络笔记（基础篇）</h2><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是<strong>网络层</strong>（<em>Internet Layer</em>）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="img"></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg" alt="img"></p><p>网络层路由：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img"></p><p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote><p>接触的比较多的是加速静态资源的访问</p></blockquote><p><a href="https://www.zhihu.com/search?q=内容分发网络&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">内容分发网络</a>（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘<a href="https://www.zhihu.com/search?q=节点服务器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">节点服务器</a>群组成的<a href="https://www.zhihu.com/search?q=分布式网络&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">分布式网络</a>。</p><p>CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。</p><p><img src="https://picx.zhimg.com/80/v2-5ba76e77f05b030b5879177bd336928f_1440w.webp?source=1940ef5c" alt="img"></p><p>借用阿里云官网的例子，来简单介绍CDN的工作原理。</p><p>假设通过CDN加速的域名为<code>www.a.com</code>，接入CDN网络，开始使用加速服务后，当<a href="https://www.zhihu.com/search?q=终端用户&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">终端用户</a>（北京）发起HTTP请求时，处理流程如下：</p><ol><li>当终端用户（北京）向<code>www.a.com</code>下的指定资源发起请求时，首先向LDNS（本地DNS）发起<a href="https://www.zhihu.com/search?q=域名解析&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">域名解析</a>请求。</li><li>LDNS检查缓存中是否有<code>www.a.com</code>的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</li><li>当授权DNS解析<code>www.a.com</code>时，返回域名CNAME <code>www.a.tbcdn.com</code>对应IP地址。</li><li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</li><li>LDNS获取DNS返回的解析IP地址。</li><li>用户获取解析IP地址。</li><li>用户向获取的IP地址发起对该资源的访问请求。</li></ol><ul><li>如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</li><li>如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</li></ul><p>从这个例子可以了解到：</p><p>（1）CDN的加速资源是跟<a href="https://www.zhihu.com/search?q=域名绑定&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">域名绑定</a>的。<br>（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP<br>（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;title-小林图解网络笔记（基础篇）&quot;&gt;&lt;a href=&quot;#title-小林图解网络笔记（基础篇）&quot; class=&quot;headerlink&quot; title=&quot;title:小林图解网络笔记（基础篇）&quot;&gt;&lt;/a&gt;title:小林图解网络笔记（基础篇）&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cookie、Session、token、JWT的区别</title>
    <link href="https://junzhengsong.github.io/2023/01/21/%E7%BD%91%E7%BB%9C%E8%AE%A4%E8%AF%81/"/>
    <id>https://junzhengsong.github.io/2023/01/21/网络认证/</id>
    <published>2023-01-21T08:39:37.000Z</published>
    <updated>2023-01-21T08:47:30.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie、Session、token、JWT的区别"><a href="#Cookie、Session、token、JWT的区别" class="headerlink" title="Cookie、Session、token、JWT的区别"></a>Cookie、Session、token、JWT的区别</h1><p>yaml front matter tags: [tag1,tag2,tag3] #[]前面要有空格</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904034181070861">傻傻分不清之 Cookie、Session、Token、JWT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cookie、Session、token、JWT的区别&quot;&gt;&lt;a href=&quot;#Cookie、Session、token、JWT的区别&quot; class=&quot;headerlink&quot; title=&quot;Cookie、Session、token、JWT的区别&quot;&gt;&lt;/a&gt;Cooki
      
    
    </summary>
    
    
      <category term="网络" scheme="https://junzhengsong.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="web前端" scheme="https://junzhengsong.github.io/tags/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="认证授权" scheme="https://junzhengsong.github.io/tags/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/20/%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://junzhengsong.github.io/2023/01/20/访问一个网页的过程/</id>
    <published>2023-01-20T07:06:56.939Z</published>
    <updated>2023-01-22T11:14:06.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问一个网页的过程"><a href="#访问一个网页的过程" class="headerlink" title="访问一个网页的过程"></a>访问一个网页的过程</h1><p><img src="https://pic2.zhimg.com/v2-abc3f530ba916274853733915e405e59_r.jpg" alt="img"></p><p>首先，出发点和目的地是浏览器，终点是服务器（HTTP Server，最主流的三个Web服务器是Apache、 Nginx 、IIS。），两者使用http协议进行交互，所以浏览器又称http client，发送的是http request请求，服务器收到请求后经过一系列过程，通过HTTP response 返回给浏览器</p><p>访问一个网页，输入url，首先使用dns协议找到IP，然后封装成http request请求报文，这些报文使用tls加密之后就变成了要发送的 应用层数据</p><p>然后到达传输层，（传输层从哪得知的IP和端口号？应用层线程告诉他的？）</p><p>到达传输层后开始进行三次握手建立TCP连接，在建立连接的时候应用数据是空的？是的√</p><p>三次握手也是要正常的经过下面的层的，只不过没传数据</p><p>将数据传送到http server（应用层应用）的时候，解析http请求，然后后端做出响应，发送给浏览器http response</p><p>浏览器根据HTTP response 内容，进行网页的构建</p><p><strong>TCP连接报文和数据报文的区别：</strong></p><p>TCP规定：SYN=1的报文段不 能 携 带 数 据 \color{red}{不能携带数据}不能携带数据。普通的TCP报文段可以携带数据，但如果不携带数据，则不消耗序号。</p><h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h3><p>在浏览器输入URL后，浏览器会将其封装成为符合HTTP格式的HTTP request请求。</p><p><img src="C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20230119213605512.png" alt="image-20230119213605512"></p><h4 id="1-1-URL"><a href="#1-1-URL" class="headerlink" title="1.1 URL"></a>1.1 URL</h4><p>URL（Uniform Resource Locator，统一资源定位符）是互联网上标准资源的地址，互联网上每个文件（即资源）都有一个唯一的URL，它包含了文件的位置以及浏览器处理方式等信息。</p><p>URL地址由协议头、服务器地址、文件路径三部分组成。比如，一个典型的URL地址<code>http://127.0.0.1:8080/subject/pythonzly/index.shtml</code>，其组成部分如图1所示。</p><p><img src="http://www.itcast.cn/files/image/202105/20210506182113556.jpg" alt="img"></p><p>常见的URL协议头包括：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http(s)://超文本传输协议</span><br><span class="line">ftp://传输文件协议</span><br><span class="line">file://获取本地文件协议</span><br></pre></td></tr></table></figure><h3 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h3><p>主要使用TCP、UDP协议，从上层接收的是</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;访问一个网页的过程&quot;&gt;&lt;a href=&quot;#访问一个网页的过程&quot; class=&quot;headerlink&quot; title=&quot;访问一个网页的过程&quot;&gt;&lt;/a&gt;访问一个网页的过程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-abc3f5
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://junzhengsong.github.io/2023/01/19/test/"/>
    <id>https://junzhengsong.github.io/2023/01/19/test/</id>
    <published>2023-01-19T15:15:37.000Z</published>
    <updated>2023-01-21T07:56:17.203Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
