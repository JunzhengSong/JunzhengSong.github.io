<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的博客</title>
  
  <subtitle>一天进步一点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://junzhengsong.github.io/"/>
  <updated>2023-01-26T08:27:25.734Z</updated>
  <id>https://junzhengsong.github.io/</id>
  
  <author>
    <name>Song Junzheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/26/%E5%9B%BE%E8%A7%A3MySQL%EF%BC%88%E9%94%81%E7%AF%87%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/26/图解MySQL（锁篇）/</id>
    <published>2023-01-26T07:53:09.837Z</published>
    <updated>2023-01-26T08:27:25.734Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="图解MySQL（锁篇）"><a href="#图解MySQL（锁篇）" class="headerlink" title="图解MySQL（锁篇）"></a>图解MySQL（锁篇）</h2><p>在 MySQL 里，根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。</p><p><img src="https://img-blog.csdnimg.cn/1e37f6994ef44714aba03b8046b1ace2.png" alt="img"></p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><blockquote><p>全局锁是怎么用的？</p></blockquote><p>要使用全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert、delete、update等语句；</li><li>对表结构的更改操作，比如 alter table、drop table 等语句。</li></ul><p>如果要释放全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>当然，当会话断开了，全局锁会被自动释放。</p><p><strong>经过测试，锁的是整个数据MySQL数据库，所有的数据库都会被锁住</strong> </p><blockquote><p>全局锁应用场景是什么？</p></blockquote><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p><blockquote><p>加全局锁又会带来什么缺点呢？</p></blockquote><p>加上全局锁，意味着整个数据库都是只读状态。</p><p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p><blockquote><p>既然备份数据库数据的时候，使用全局锁                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               会影响业务，那有什么其他方式可以避免？</p></blockquote><p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p><p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p><p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p><p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p><p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><blockquote><p>MySQL 表级锁有哪些？具体怎么用的。</p></blockquote><p>MySQL 里面表级别的锁有这几种：</p><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁；</li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>先来说说<strong>表锁</strong>。</p><p>如果我们想对学生表（t_student）加表锁，可以使用下面的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br></pre></td></tr></table></figure><p>需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p><p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p><p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>另外，当会话退出后，也会释放所有表锁。</p><p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>再来说说<strong>元数据锁</strong>（MDL）。</p><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><blockquote><p>MDL 不需要显示调用，那它是在什么时候释放的?</p></blockquote><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p><blockquote><p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p></blockquote><p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>接着，说说<strong>意向锁</strong>。</p><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些记录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p><p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p><p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>先在表上加上意向共享锁，然后对读取的记录加共享锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>先表上加上意向独占锁，然后对读取的记录加独占锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables … read*）和独占表锁（*lock tables … write*）发生冲突。</strong></p><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h3 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h3><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。</p><p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p><p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p><p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p><p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p><p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p><ul><li>当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li><li>当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li><li>当 innodb_autoinc_lock_mode = 1：<ul><li>普通 insert 语句，自增锁在申请之后就马上释放；</li><li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li></ul></li></ul><p>当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生<strong>数据不一致的问题</strong>。</p><p>举个例子，考虑下面场景：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/innodb_autoinc_lock_mode=2.png" alt="img"></p><p>session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后<strong>两个 session 同时执行向表 t2 中插入数据</strong>。</p><p>如果 innodb_autoinc_lock_mode = 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：</p><ul><li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；</li><li>然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；</li><li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</li></ul><p>可以看到，<strong>session B 的 insert 语句，生成的 id 不连续</strong>。</p><p>当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format=statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。</p><p>但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在<strong>从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致</strong>。</p><p>要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p><p>所以，<strong>当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题</strong>。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p><p>前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。</p><p>共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/x%E9%94%81%E5%92%8Cs%E9%94%81.png" alt="img"></p><p>行级锁的类型主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock: Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;图解MySQL（锁篇）&quot;&gt;&lt;a href=&quot;#图解MySQL（锁篇）&quot; class=&quot;headerlink&quot; title=&quot;图解MySQL（锁篇）&quot;&gt;&lt;/a&gt;图解MySQL（锁篇）&lt;/h2&gt;&lt;p&gt;在 MySQL 里，根据加锁的范围，可以分为&lt;strong
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/26/%E5%9B%BE%E8%A7%A3MySQL%EF%BC%88%E4%BA%8B%E7%89%A9%E7%AF%87%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/26/图解MySQL（事物篇）/</id>
    <published>2023-01-26T07:52:15.602Z</published>
    <updated>2023-01-26T14:11:29.269Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="图解MySQL（事物篇）"><a href="#图解MySQL（事物篇）" class="headerlink" title="图解MySQL（事物篇）"></a>图解MySQL（事物篇）</h2><p>我们在转账操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态。</p><p>没错，今天就来图解 MySQL 事务啦，开车！</p><p><img src="https://img-blog.csdnimg.cn/eb15d4b6a9d543c1be4f7090479d969c.png" alt="img"></p><hr><h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="#事务有哪些特性？"></a><a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#事务有哪些特性">#</a>事务有哪些特性？</h2><p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p><p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。</p><p>事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;图解MySQL（事物篇）&quot;&gt;&lt;a href=&quot;#图解MySQL（事物篇）&quot; class=&quot;headerlink&quot; title=&quot;图解MySQL（事物篇）&quot;&gt;&lt;/a&gt;图解MySQL（事物篇）&lt;/h2&gt;&lt;p&gt;我们在转账操作前先开启事务，等所有数据库操作执行完
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/26/%E5%9B%BE%E8%A7%A3MySQL%EF%BC%88%E7%B4%A2%E5%BC%95%E7%AF%87%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/26/图解MySQL（索引篇）/</id>
    <published>2023-01-26T07:49:04.114Z</published>
    <updated>2023-01-26T10:32:53.503Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="图解MySQL（索引篇）"><a href="#图解MySQL（索引篇）" class="headerlink" title="图解MySQL（索引篇）"></a>图解MySQL（索引篇）</h2><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;图解MySQL（索引篇）&quot;&gt;&lt;a href=&quot;#图解MySQL（索引篇）&quot; class=&quot;headerlink&quot; title=&quot;图解MySQL（索引篇）&quot;&gt;&lt;/a&gt;图解MySQL（索引篇）&lt;/h2&gt;&lt;h2 id=&quot;什么是索引？&quot;&gt;&lt;a href=&quot;#什么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/24/MySQL%E7%AC%94%E8%AE%B0/"/>
    <id>https://junzhengsong.github.io/2023/01/24/MySQL笔记/</id>
    <published>2023-01-24T04:52:42.241Z</published>
    <updated>2023-01-26T09:11:46.940Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="MySQL笔记"><a href="#MySQL笔记" class="headerlink" title="MySQL笔记"></a>MySQL笔记</h2><h2 id="MySQL命令"><a href="#MySQL命令" class="headerlink" title="MySQL命令"></a>MySQL命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql -u username -p//登录</span><br><span class="line">//单个sql可以不加分号？但是在cmd中单条select不加分号会当作换行，好像是命令行都需要加换行</span><br><span class="line">select database();//显示当前数据库</span><br><span class="line">use  数据库名 //切换数据库</span><br><span class="line">show databases;//显示所有数据库</span><br><span class="line">show tables; //显示当前数据库所有表：</span><br><span class="line">show columns from 数据表;//：显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息</span><br><span class="line">show index from 数据表;  //显示数据表的详细索引信息，包括PRIMARY KEY（主键）。</span><br><span class="line">CREATE DATABASE 数据库名;</span><br><span class="line">drop database 数据库名;</span><br><span class="line">CREATE TABLE table_name (column_name column_type);</span><br><span class="line">DROP TABLE table_name ;</span><br><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br><span class="line">                       //value如果是字符型，需要使用单引号或双引号</span><br><span class="line">SELECT column_name,column_name FROM table_name;</span><br><span class="line">SELECT * from runoob_tbl WHERE runoob_author=&#x27;菜鸟教程&#x27;</span><br><span class="line">group by</span><br><span class="line">having</span><br><span class="line">order by</span><br><span class="line">UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause]</span><br><span class="line">DELETE FROM table_name [WHERE Clause]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `runoob_tbl`(</span><br><span class="line">   `runoob_id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   `runoob_title` VARCHAR(100) NOT NULL,</span><br><span class="line">   `runoob_author` VARCHAR(40) NOT NULL,</span><br><span class="line">   `submission_date` DATE,</span><br><span class="line">   PRIMARY KEY ( `runoob_id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="MySQL语句"><a href="#MySQL语句" class="headerlink" title="MySQL语句"></a>MySQL语句</h2><h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h2><ul><li><strong>MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写</strong>。因此，数据库名、 表名、字段名，都不允许出现任何大写字母，避免节外生枝。</li><li></li></ul><h3 id="delete-drop-truncate对比"><a href="#delete-drop-truncate对比" class="headerlink" title="delete, drop, truncate对比"></a>delete, drop, truncate对比</h3><p>相同点：</p><ul><li>truncate和不带where子句的delete、以及drop都会删除表内的数据。</li><li>drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。</li></ul><p>不同点：</p><ul><li>truncate 和 delete 只删除数据不删除表的结构(定义)，drop 语句将删除表的结构所依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。</li></ul><ul><li><p>delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。<br>truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</p></li><li><p>速度，一般来说: drop&gt; truncate &gt; delete</p></li></ul><blockquote><p>constrain: 例如not null, unique, primary key, foreign key</p><p>trigger: 触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。</p><p>rollback segement: 回滚段，用来存放undo log，mysql回滚是通过undo完成的</p></blockquote><h3 id="什么是ACID？"><a href="#什么是ACID？" class="headerlink" title="什么是ACID？"></a>什么是ACID？</h3><p><strong>ACID</strong>，是指<strong>数据库</strong>管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;MySQL笔记&quot;&gt;&lt;a href=&quot;#MySQL笔记&quot; class=&quot;headerlink&quot; title=&quot;MySQL笔记&quot;&gt;&lt;/a&gt;MySQL笔记&lt;/h2&gt;&lt;h2 id=&quot;MySQL命令&quot;&gt;&lt;a href=&quot;#MySQL命令&quot; class=&quot;heade
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/24/Redis%E7%AC%94%E8%AE%B0/"/>
    <id>https://junzhengsong.github.io/2023/01/24/Redis笔记/</id>
    <published>2023-01-24T04:26:03.439Z</published>
    <updated>2023-01-24T04:52:31.765Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Redis学习笔记（一）"><a href="#Redis学习笔记（一）" class="headerlink" title="Redis学习笔记（一）"></a>Redis学习笔记（一）</h2><h3 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h3><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p><p>Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p><p>除此之外，Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制</strong>等等。 </p><blockquote><ul><li>消息队列：消息队列是一种异步的服务间通信方式，适用于无服务器和微服务架构。消息在被处理和删除之前一直存储在队列上。每条消息仅可被一位用户处理一次。消息队列可被用于分离重量级处理、缓冲或批处理工作以及缓解高峰期工作负载。解耦、削峰、限流</li><li>分布式锁：控制分布式系统不同进程共同访问共享资源的一种锁的实现。</li><li>原子性：一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>事物：访问并可能操作各种数据项的一个数据库操作序列</li><li></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;Redis学习笔记（一）&quot;&gt;&lt;a href=&quot;#Redis学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;Redis学习笔记（一）&quot;&gt;&lt;/a&gt;Redis学习笔记（一）&lt;/h2&gt;&lt;h3 id=&quot;什么是Redis？&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/22/%E5%B0%8F%E6%9E%97%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/22/小林网络笔记（总结）/</id>
    <published>2023-01-22T11:26:33.624Z</published>
    <updated>2023-01-22T11:26:52.901Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/22/%E5%B0%8F%E6%9E%97%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/22/小林网络笔记（四）/</id>
    <published>2023-01-22T11:26:33.624Z</published>
    <updated>2023-01-22T11:26:33.624Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/22/%E5%B0%8F%E6%9E%97%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/22/小林网络笔记（三）/</id>
    <published>2023-01-22T11:25:00.469Z</published>
    <updated>2023-01-23T13:23:44.005Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="小林图解网络（TCP篇）"><a href="#小林图解网络（TCP篇）" class="headerlink" title="小林图解网络（TCP篇）"></a>小林图解网络（TCP篇）</h2><h1 id="4-1-TCP-三次握手与四次挥手面试题"><a href="#4-1-TCP-三次握手与四次挥手面试题" class="headerlink" title="4.1 TCP 三次握手与四次挥手面试题"></a>4.1 TCP 三次握手与四次挥手面试题</h1><h3 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h3><p><img src="https://img-blog.csdnimg.cn/1310bf5ed78e4c8186481c47719e0793.png" alt="img"></p><hr><h2 id="TCP-基本认识"><a href="#TCP-基本认识" class="headerlink" title="TCP 基本认识"></a>TCP 基本认识</h2><h3 id="TCP-头格式有哪些？"><a href="#TCP-头格式有哪些？" class="headerlink" title="TCP 头格式有哪些？"></a>TCP 头格式有哪些？</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn?x-oss-process=image/format,png" alt="TCP 头格式"></p><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><blockquote><p>SYN为1的TCP报文段不能含有数据</p></blockquote><h3 id="为什么需要-TCP-协议？-TCP-工作在哪一层？"><a href="#为什么需要-TCP-协议？-TCP-工作在哪一层？" class="headerlink" title="为什么需要 TCP 协议？ TCP 工作在哪一层？"></a>为什么需要 TCP 协议？ TCP 工作在哪一层？</h3><p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzcuanBn?x-oss-process=image/format,png" alt="OSI 参考模型与 TCP/IP 的关系"></p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h3 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzguanBn?x-oss-process=image/format,png" alt="img"></p><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><blockquote><p><strong>我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议</strong>。</p></blockquote><h3 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h3><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzkuanBn?x-oss-process=image/format,png" alt="img"></p><p>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><h3 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a>如何唯一确定一个 TCP 连接呢？</h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEwLmpwZw?x-oss-process=image/format,png" alt="TCP 四元组"></p><p>源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p><p>源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p><h3 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p><p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（64 位），UDP 的头部格式如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEyLmpwZw?x-oss-process=image/format,png" alt="UDP 头部格式"></p><ul><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><p><strong>TCP 和 UDP 区别：</strong></p><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><strong>TCP 和 UDP 应用场景：</strong></p><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP / HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;小林图解网络（TCP篇）&quot;&gt;&lt;a href=&quot;#小林图解网络（TCP篇）&quot; class=&quot;headerlink&quot; title=&quot;小林图解网络（TCP篇）&quot;&gt;&lt;/a&gt;小林图解网络（TCP篇）&lt;/h2&gt;&lt;h1 id=&quot;4-1-TCP-三次握手与四次挥手面试题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/22/%E5%B0%8F%E6%9E%97%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/22/小林网络笔记（二）/</id>
    <published>2023-01-22T11:25:00.469Z</published>
    <updated>2023-01-23T12:51:57.232Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="小林图解网络（HTTP篇）"><a href="#小林图解网络（HTTP篇）" class="headerlink" title="小林图解网络（HTTP篇）"></a>小林图解网络（HTTP篇）</h2><h2 id="HTTP-基本概念"><a href="#HTTP-基本概念" class="headerlink" title="HTTP 基本概念"></a>HTTP 基本概念</h2><h3 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h3><p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li><p>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p></li><li><p>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</p></li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h3 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h3><p><em>Host</em> 字段</p><p>客户端发送请求时，用来指定服务器的域名。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/7-HOST%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.A.com</span><br></pre></td></tr></table></figure><p>有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</p><p><em>Content-Length 字段</em></p><p>服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/8-content-length%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 1000</span><br></pre></td></tr></table></figure><p>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p><p>大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，<strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong>。具体什么是 TCP 粘包，可以看这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/tcp_stream.html">如何理解是 TCP 面向字节流协议？(opens new window)</a></p><p><em>Connection 字段</em></p><p><code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/9-connection%E5%AD%97%E6%AE%B5.png" alt="img"></p><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d2b20d1cc03936332adb2a68512eb167.png" alt="HTTP 长连接"></p><p>HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p>开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</p><p>PS：大家不要把 HTTP Keep-Alive 和 TCP Keepalive 搞混了，这两个虽然长的像，但是不是一个东西，具体可以看我这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html">TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？(opens new window)</a></p><p><em>Content-Type 字段</em></p><p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/10-content-type%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; Charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p><p><em>Content-Encoding 字段</em></p><p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/11-content-encoding%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p><p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;小林图解网络（HTTP篇）&quot;&gt;&lt;a href=&quot;#小林图解网络（HTTP篇）&quot; class=&quot;headerlink&quot; title=&quot;小林图解网络（HTTP篇）&quot;&gt;&lt;/a&gt;小林图解网络（HTTP篇）&lt;/h2&gt;&lt;h2 id=&quot;HTTP-基本概念&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/22/%E5%B0%8F%E6%9E%97%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://junzhengsong.github.io/2023/01/22/小林网络笔记（一）/</id>
    <published>2023-01-22T10:37:07.181Z</published>
    <updated>2023-01-22T11:24:46.490Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-小林图解网络笔记（基础篇）"><a href="#title-小林图解网络笔记（基础篇）" class="headerlink" title="title:小林图解网络笔记（基础篇）"></a>title:小林图解网络笔记（基础篇）</h2><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是<strong>网络层</strong>（<em>Internet Layer</em>）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="img"></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg" alt="img"></p><p>网络层路由：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img"></p><p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote><p>接触的比较多的是加速静态资源的访问</p></blockquote><p><a href="https://www.zhihu.com/search?q=内容分发网络&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">内容分发网络</a>（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘<a href="https://www.zhihu.com/search?q=节点服务器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">节点服务器</a>群组成的<a href="https://www.zhihu.com/search?q=分布式网络&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">分布式网络</a>。</p><p>CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。</p><p><img src="https://picx.zhimg.com/80/v2-5ba76e77f05b030b5879177bd336928f_1440w.webp?source=1940ef5c" alt="img"></p><p>借用阿里云官网的例子，来简单介绍CDN的工作原理。</p><p>假设通过CDN加速的域名为<code>www.a.com</code>，接入CDN网络，开始使用加速服务后，当<a href="https://www.zhihu.com/search?q=终端用户&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">终端用户</a>（北京）发起HTTP请求时，处理流程如下：</p><ol><li>当终端用户（北京）向<code>www.a.com</code>下的指定资源发起请求时，首先向LDNS（本地DNS）发起<a href="https://www.zhihu.com/search?q=域名解析&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">域名解析</a>请求。</li><li>LDNS检查缓存中是否有<code>www.a.com</code>的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</li><li>当授权DNS解析<code>www.a.com</code>时，返回域名CNAME <code>www.a.tbcdn.com</code>对应IP地址。</li><li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</li><li>LDNS获取DNS返回的解析IP地址。</li><li>用户获取解析IP地址。</li><li>用户向获取的IP地址发起对该资源的访问请求。</li></ol><ul><li>如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</li><li>如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</li></ul><p>从这个例子可以了解到：</p><p>（1）CDN的加速资源是跟<a href="https://www.zhihu.com/search?q=域名绑定&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1604554133}">域名绑定</a>的。<br>（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP<br>（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;title-小林图解网络笔记（基础篇）&quot;&gt;&lt;a href=&quot;#title-小林图解网络笔记（基础篇）&quot; class=&quot;headerlink&quot; title=&quot;title:小林图解网络笔记（基础篇）&quot;&gt;&lt;/a&gt;title:小林图解网络笔记（基础篇）&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cookie、Session、token、JWT的区别</title>
    <link href="https://junzhengsong.github.io/2023/01/21/%E7%BD%91%E7%BB%9C%E8%AE%A4%E8%AF%81/"/>
    <id>https://junzhengsong.github.io/2023/01/21/网络认证/</id>
    <published>2023-01-21T08:39:37.000Z</published>
    <updated>2023-01-21T08:47:30.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie、Session、token、JWT的区别"><a href="#Cookie、Session、token、JWT的区别" class="headerlink" title="Cookie、Session、token、JWT的区别"></a>Cookie、Session、token、JWT的区别</h1><p>yaml front matter tags: [tag1,tag2,tag3] #[]前面要有空格</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904034181070861">傻傻分不清之 Cookie、Session、Token、JWT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cookie、Session、token、JWT的区别&quot;&gt;&lt;a href=&quot;#Cookie、Session、token、JWT的区别&quot; class=&quot;headerlink&quot; title=&quot;Cookie、Session、token、JWT的区别&quot;&gt;&lt;/a&gt;Cooki
      
    
    </summary>
    
    
      <category term="网络" scheme="https://junzhengsong.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="web前端" scheme="https://junzhengsong.github.io/tags/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="认证授权" scheme="https://junzhengsong.github.io/tags/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://junzhengsong.github.io/2023/01/20/%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://junzhengsong.github.io/2023/01/20/访问一个网页的过程/</id>
    <published>2023-01-20T07:06:56.939Z</published>
    <updated>2023-01-22T11:14:06.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问一个网页的过程"><a href="#访问一个网页的过程" class="headerlink" title="访问一个网页的过程"></a>访问一个网页的过程</h1><p><img src="https://pic2.zhimg.com/v2-abc3f530ba916274853733915e405e59_r.jpg" alt="img"></p><p>首先，出发点和目的地是浏览器，终点是服务器（HTTP Server，最主流的三个Web服务器是Apache、 Nginx 、IIS。），两者使用http协议进行交互，所以浏览器又称http client，发送的是http request请求，服务器收到请求后经过一系列过程，通过HTTP response 返回给浏览器</p><p>访问一个网页，输入url，首先使用dns协议找到IP，然后封装成http request请求报文，这些报文使用tls加密之后就变成了要发送的 应用层数据</p><p>然后到达传输层，（传输层从哪得知的IP和端口号？应用层线程告诉他的？）</p><p>到达传输层后开始进行三次握手建立TCP连接，在建立连接的时候应用数据是空的？是的√</p><p>三次握手也是要正常的经过下面的层的，只不过没传数据</p><p>将数据传送到http server（应用层应用）的时候，解析http请求，然后后端做出响应，发送给浏览器http response</p><p>浏览器根据HTTP response 内容，进行网页的构建</p><p><strong>TCP连接报文和数据报文的区别：</strong></p><p>TCP规定：SYN=1的报文段不 能 携 带 数 据 \color{red}{不能携带数据}不能携带数据。普通的TCP报文段可以携带数据，但如果不携带数据，则不消耗序号。</p><h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h3><p>在浏览器输入URL后，浏览器会将其封装成为符合HTTP格式的HTTP request请求。</p><p><img src="C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20230119213605512.png" alt="image-20230119213605512"></p><h4 id="1-1-URL"><a href="#1-1-URL" class="headerlink" title="1.1 URL"></a>1.1 URL</h4><p>URL（Uniform Resource Locator，统一资源定位符）是互联网上标准资源的地址，互联网上每个文件（即资源）都有一个唯一的URL，它包含了文件的位置以及浏览器处理方式等信息。</p><p>URL地址由协议头、服务器地址、文件路径三部分组成。比如，一个典型的URL地址<code>http://127.0.0.1:8080/subject/pythonzly/index.shtml</code>，其组成部分如图1所示。</p><p><img src="http://www.itcast.cn/files/image/202105/20210506182113556.jpg" alt="img"></p><p>常见的URL协议头包括：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http(s)://超文本传输协议</span><br><span class="line">ftp://传输文件协议</span><br><span class="line">file://获取本地文件协议</span><br></pre></td></tr></table></figure><h3 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h3><p>主要使用TCP、UDP协议，从上层接收的是</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;访问一个网页的过程&quot;&gt;&lt;a href=&quot;#访问一个网页的过程&quot; class=&quot;headerlink&quot; title=&quot;访问一个网页的过程&quot;&gt;&lt;/a&gt;访问一个网页的过程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-abc3f5
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://junzhengsong.github.io/2023/01/19/test/"/>
    <id>https://junzhengsong.github.io/2023/01/19/test/</id>
    <published>2023-01-19T15:15:37.000Z</published>
    <updated>2023-01-21T07:56:17.203Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
